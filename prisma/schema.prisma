generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

model ActivityLogs {
  ID          BigInt   @id(map: "PK_ActivityLogs") @default(autoincrement())
  OrderNumber String?  @db.NVarChar(50)
  Description String?  @db.NVarChar(Max)
  DateAdded   DateTime @db.DateTime
  CustomerId  BigInt?
  AddressId   BigInt?
  OrderId     BigInt?
  // Extended audit fields
  EntityType  String?  @db.NVarChar(50)    // 'order', 'shipment', 'customer', 'item'
  EntityID    BigInt?
  Action      String?  @db.NVarChar(100)   // 'shipment_created', 'item_cancelled', etc.
  OldValues   String?  @db.NVarChar(Max)   // JSON of previous state
  NewValues   String?  @db.NVarChar(Max)   // JSON of new state
  PerformedBy String?  @db.NVarChar(255)
  IPAddress   String?  @db.NVarChar(50)
  UserAgent   String?  @db.NVarChar(500)

  @@index([EntityType, EntityID], map: "IX_ActivityLogs_EntityType")
  @@index([Action], map: "IX_ActivityLogs_Action")
  @@index([DateAdded(sort: Desc)], map: "IX_ActivityLogs_DateAdded")
}

model ApplicationExceptions {
  ExceptionId         BigInt   @id(map: "PK_ApplicationExceptions") @default(autoincrement())
  ExceptionMethod     String   @db.NVarChar(250)
  ExceptionMessage    String   @db.NVarChar(500)
  ExceptionStackTrace String?  @db.NVarChar(Max)
  ExceptionDateTime   DateTime @db.DateTime
  ExceptionURL        String?  @db.NVarChar(300)
}

model CustomerOrders {
  ID                     BigInt                   @id(map: "PK_CustomerOrders") @default(autoincrement())
  OrderNumber            String                   @db.NVarChar(50)
  BuyerName              String                   @db.NVarChar(500)
  StoreName              String                   @db.NVarChar(500)
  SalesRep               String                   @db.NVarChar(200)
  CustomerEmail          String                   @db.NVarChar(500)
  Country                String                   @db.NVarChar(20)
  CustomerPhone          String                   @db.NVarChar(100)
  OrderAmount            Float
  OrderNotes             String                   @db.NVarChar(Max)
  CustomerPO             String                   @db.NVarChar(100)
  ShipStartDate          DateTime                 @db.DateTime
  ShipEndDate            DateTime                 @db.DateTime
  OrderDate              DateTime                 @db.DateTime
  Website                String                   @db.NVarChar(200)
  IsShipped              Boolean
  OrderStatus            String                   @db.NVarChar(50)
  IsTransferredToShopify Boolean?
  IsPreOrder             Boolean?
  CustomerID             Int?
  RepID                  Int?
  ShopifyOrderID             String?                  @db.NVarChar(50)
  ShopifyFulfillmentStatus   String?                  @db.NVarChar(20)
  ShopifyFinancialStatus     String?                  @db.NVarChar(20)
  ShopifyStatusSyncedAt      DateTime?                @db.DateTime
  PaymentTerms               String?                  @db.NVarChar(200)
  ApprovalDate               DateTime?                @db.DateTime
  BrandNotes                 String?                  @db.NVarChar(Max)
  // Email preference tracking for order confirmation popup
  EmailSentCustomer          Boolean?                 @default(false)
  EmailSentRep               Boolean?                 @default(false)
  EmailSentAdmin             Boolean?                 @default(false)
  EmailAdditionalTo          String?                  @db.NVarChar(Max) // JSON array of additional recipients
  EmailSentAt                DateTime?                @db.DateTime
  CustomerOrdersComments     CustomerOrdersComments[]
  CustomerOrdersItems        CustomerOrdersItems[]
  Shipments                  Shipments[]

  @@index([CustomerID], map: "IX_CustomerOrders_CustomerID")
  @@index([OrderDate], map: "IX_CustomerOrders_OrderDate")
  @@index([RepID], map: "IX_CustomerOrders_RepID")
}

model CustomerOrdersComments {
  ID             BigInt         @id(map: "PK_CustomerOrdersComments") @default(autoincrement())
  OrderID        BigInt
  Comments       String         @db.NVarChar(Max)
  AddedDate      DateTime       @db.DateTime
  AddedBy        String         @db.NVarChar(500)
  CustomerOrders CustomerOrders @relation(fields: [OrderID], references: [ID], onUpdate: NoAction, map: "FK_CustomerOrdersComments_CustomerOrders")
}

model CustomerOrdersItems {
  ID                BigInt          @id(map: "PK_CustomerOrdersItems") @default(autoincrement())
  CustomerOrderID   BigInt
  OrderNumber       String          @db.NVarChar(50)
  SKU               String          @db.NVarChar(50)
  SKUVariantID      BigInt
  ShopifyLineItemID String?         @db.NVarChar(50) // Shopify line_item.id for precise fulfillment mapping
  Quantity          Int
  Price           Float
  PriceCurrency   String          @db.NVarChar(50)
  Notes           String          @db.NVarChar(Max)
  LineDiscount    Float?          @default(0)
  // Line item fulfillment status tracking
  Status          String?         @default("Open") @db.NVarChar(20) // Open | Shipped | Cancelled
  CancelledQty    Int?            @default(0)
  CancelledReason String?         @db.NVarChar(100) // "Out of stock", "Discontinued", "Customer request", etc.
  CancelledAt     DateTime?       @db.DateTime
  CancelledBy     String?         @db.NVarChar(255)
  CustomerOrders  CustomerOrders  @relation(fields: [CustomerOrderID], references: [ID], onUpdate: NoAction, map: "FK_CustomerOrdersItems_CustomerOrders")
  ShipmentItems   ShipmentItems[]

  @@index([CustomerOrderID], map: "IX_CustomerOrdersItems_CustomerOrderID")
}

model Customers {
  ID                    Int       @id(map: "PK_Customers") @default(autoincrement())
  StoreName             String    @db.NVarChar(500)
  Email                 String?   @db.NVarChar(500)
  CustomerName          String?   @db.NVarChar(500)
  Phone                 String?   @db.NVarChar(500)
  Rep                   String?   @db.NVarChar(500)
  Street1               String?   @db.NVarChar(500)
  Street2               String?   @db.NVarChar(500)
  City                  String?   @db.NVarChar(500)
  StateProvince         String?   @db.NVarChar(500)
  ZipPostal             String?   @db.NVarChar(500)
  Country               String?   @db.NVarChar(500)
  AdditionalInfo        String?   @db.NVarChar(Max)
  ShippingStreet1       String?   @db.NVarChar(500)
  ShippingStreet2       String?   @db.NVarChar(500)
  ShippingCity          String?   @db.NVarChar(500)
  ShippingStateProvince String?   @db.NVarChar(500)
  ShippingZipPostal     String?   @db.NVarChar(500)
  ShippingCountry       String?   @db.NVarChar(500)
  Website               String?   @db.NVarChar(500)
  FirstOrderDate        DateTime? @db.DateTime
  LTV                   Decimal?  @db.Decimal(18, 2)
  Segment               String?   @db.NVarChar(20)
  UsualOrderCycle       Int?
  LastOrderDate         DateTime? @db.DateTime
  OrderCount            Int?      @default(0, map: "DF__Customers__Order__1DB06A4F")
  EstimatedPotential    Decimal?  @db.Decimal(18, 2)

  @@index([LastOrderDate], map: "IX_Customers_LastOrderDate")
  @@index([Segment], map: "IX_Customers_Segment")
}

model CustomersFromShopify {
  ID        BigInt @id(map: "PK_CustomersFromShopify")
  ShopifyID String @db.NVarChar(100)
  Email     String @db.NVarChar(200)
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model DB_Errors {
  ErrorID        Int       @default(autoincrement())
  UserName       String?   @db.VarChar(100)
  ErrorNumber    Int?
  ErrorState     Int?
  ErrorSeverity  Int?
  ErrorLine      Int?
  ErrorProcedure String?   @db.VarChar(Max)
  ErrorMessage   String?   @db.VarChar(Max)
  ErrorDateTime  DateTime? @db.DateTime

  @@ignore
}

model InventorySettings {
  ID                  Int      @id(map: "PK_InventorySettings") @default(autoincrement())
  MinQuantityToShow   Int
  CanadaPassword      String   @db.NVarChar(50)
  USAPassword         String   @db.NVarChar(50)
  CanadaUSAPassword   String?  @db.NVarChar(50)
  AllowMultipleImages Boolean?
  EnableZoom          Boolean?
  ImageRefreshCounter Int
  USDToCADConversion  Float?
  ShowShopifyImages   Boolean?
}

/// Company settings for PDF generation and branding
model CompanySettings {
  ID           Int     @id(map: "PK_CompanySettings") @default(autoincrement())
  CompanyName  String  @db.NVarChar(200)
  AddressLine1 String? @db.NVarChar(200)
  AddressLine2 String? @db.NVarChar(200)
  Phone        String? @db.NVarChar(50)
  Fax          String? @db.NVarChar(50)
  Email        String? @db.NVarChar(200)
  Website      String? @db.NVarChar(200)
  LogoUrl      String? @db.NVarChar(500)
}

/// Email notification settings - configurable via admin panel
model EmailSettings {
  ID                       Int      @id(map: "PK_EmailSettings") @default(autoincrement())
  FromEmail                String   @db.NVarChar(200)
  FromName                 String?  @db.NVarChar(200)
  SalesTeamEmails          String?  @db.NVarChar(500)
  CCEmails                 String?  @db.NVarChar(500)
  NotifyOnNewOrder         Boolean  @default(true)
  NotifyOnOrderUpdate      Boolean  @default(false)
  SendCustomerConfirmation Boolean  @default(true)
  UpdatedAt                DateTime @default(now()) @updatedAt

  // SMTP Configuration - falls back to .env if not set
  SmtpHost                 String?  @db.NVarChar(200)
  SmtpPort                 Int?
  SmtpUser                 String?  @db.NVarChar(200)
  SmtpPassword             String?  @db.NVarChar(500)
  SmtpSecure               Boolean  @default(false)
}

model MissingShopifySkus {
  ID                      BigInt   @id(map: "PK_MissingShopifySkus") @default(autoincrement())
  SkuID                   String   @db.NVarChar(50)
  Description             String   @db.NVarChar(Max)
  Quantity                Int
  Price                   String   @db.NVarChar(50)
  FabricContent           String   @db.NVarChar(500)
  SkuColor                String   @db.NVarChar(50)
  DateAdded               DateTime @db.DateTime
  DateModified            DateTime @db.DateTime
  CategoryID              Int
  PriceCAD                String   @db.NVarChar(50)
  PriceUSD                String   @db.NVarChar(50)
  OrderEntryDescription   String   @db.NVarChar(500)
  MSRPCAD                 String   @db.NVarChar(50)
  MSRPUSD                 String   @db.NVarChar(50)
  Season                  String   @db.NVarChar(500)
  IsReviewed              Boolean
  ShopifyProductVariantId BigInt?
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model MultiCategorySkus {
  SkuId        String?   @db.NVarChar(100)
  SyncOrder    Int?
  MFCollection String?   @db.NVarChar(Max)
  DateAdded    DateTime? @db.DateTime

  @@ignore
}

model OrderDetails {
  ID                  Int    @id(map: "PK_OrderDetails") @default(autoincrement())
  OrderID             Int
  SkuID               String @db.VarChar(50)
  Size                String @db.NVarChar(50)
  Quantity            Int
  TotalAmount         Float
  TotalAmountCurrency String @db.NVarChar(50)
  Orders              Orders @relation(fields: [OrderID], references: [ID], onUpdate: NoAction, map: "FK_OrderDetails_Orders")
}

model Orders {
  ID            Int            @id(map: "PK_Orders") @default(autoincrement())
  DateAdded     DateTime       @default(now(), map: "DF_Orders_DateAdded") @db.DateTime
  OrderAmount   Float
  OrderCurrency String         @db.NVarChar(50)
  CustomerID    Int
  OrderDetails  OrderDetails[]
}

model PPSizes {
  ID              Int    @id(map: "PK_PPSizes") @default(autoincrement())
  Size            Int
  CorrespondingPP String @db.NVarChar(50)
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model PreOrderPriceUpdates {
  Sku      String @db.NVarChar(50)
  PriceUSD Float
  MSRPUSD  Float
  PriceCAD Float
  MSRPCAD  Float

  @@ignore
}

model RawSkusFromShopify {
  ID                                Int     @id(map: "PK_RawSkusFromShopify") @default(autoincrement())
  SkuID                             String  @db.NVarChar(Max)
  Quantity                          Int
  DisplayName                       String  @db.NVarChar(Max)
  Size                              String  @db.NVarChar(Max)
  Price                             Float
  AvailableForSale                  Boolean
  RawShopifyId                      String? @db.NVarChar(Max)
  ShopifyId                         BigInt?
  VariantWeight                     Float?
  VariantWeightUnit                 String? @db.NVarChar(50)
  VariantWeightInGrams              Float?
  productId                         String? @db.NVarChar(500)
  ProductType                       String? @db.NVarChar(200)
  metafield_order_entry_collection  String? @db.NVarChar(200)
  metafield_order_entry_description String? @db.NVarChar(Max)
  metafield_msrp                    String? @db.NVarChar(Max)
  metafield_cad_ws_price            String? @db.NVarChar(Max)
  metafield_features                String? @db.NVarChar(Max)
  metafield_fabric                  String? @db.NVarChar(Max)
  metafield_color                   String? @db.NVarChar(Max)
  colorFromMetafield                String? @db.NVarChar(Max)
  metafield_usd_ws_price            String? @db.NVarChar(Max)
  metafield_cad_ws_price_test       String? @db.NVarChar(Max)
  metafield_msrp_us                 String? @db.NVarChar(Max)
  metafield_msrp_cad                String? @db.NVarChar(Max)
  ShopifyProductImageURL            String? @db.NVarChar(500)
  InventoryItemId                   String? @db.NVarChar(100)
  ProductStatus                     String? @db.NVarChar(20) // ACTIVE, ARCHIVED, DRAFT
}

model RawSkusInventoryLevelFromShopify {
  ID                BigInt @id(map: "PK_RawSkusInventoryLevelFromShopify") @default(autoincrement())
  InventoryLevelId  String @db.NVarChar(Max)
  Incoming          Int
  ParentId          String @db.NVarChar(Max)
  CommittedQuantity Int?
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model RawSkusVariantFromShopify {
  ID              BigInt    @default(autoincrement())
  ParentID        String?   @db.NVarChar(Max)
  VariantImageUrl String?   @db.NVarChar(Max)
  AddedOn         DateTime? @default(now(), map: "DF_RawSkusVariantFromShopify_AddedOn") @db.DateTime

  @@ignore
}

model Reps {
  ID                    Int          @id(map: "PK_Reps") @default(autoincrement())
  Name                  String       @db.NVarChar(500)
  Code                  String       @db.NVarChar(100)
  Address               String       @db.NVarChar(Max)
  Phone                 String       @db.NVarChar(50)
  Fax                   String       @db.NVarChar(50)
  Cell                  String       @db.NVarChar(50)
  Email1                String       @db.NVarChar(250)
  Email2                String       @db.NVarChar(250)
  Email3                String       @db.NVarChar(250)
  Country               String       @db.NVarChar(50)
  Territory             String?      @db.NVarChar(100)
  // Default email preference for order confirmation popup
  DefaultSendOrderEmail Boolean?     @default(true)
  RepTargets            RepTargets[]
  Users                 Users[]
}

model ShopifySyncLog {
  ID              BigInt   @id(map: "PK_ShopifySyncLog") @default(autoincrement())
  RawShopifySkuID String   @db.NVarChar(100)
  SkuID           String   @db.NVarChar(100)
  RawSkuQuantity  Int
  SkuQuantity     Int
  SyncDataTime    DateTime @db.DateTime
  SyncOrder       Int
}

/// Tracks Shopify bulk sync operations (run-level, not per-SKU).
/// Note: This table must be created in production by DBA - see SQL script in plan.
model ShopifySyncRun {
  ID                BigInt    @id(map: "PK_ShopifySyncRun") @default(autoincrement())
  SyncType          String    @db.NVarChar(20)
  Status            String    @db.NVarChar(20)
  OperationId       String?   @db.NVarChar(255)
  StartedAt         DateTime  @db.DateTime
  CompletedAt       DateTime? @db.DateTime
  ItemCount         Int?
  ErrorMessage      String?   @db.NVarChar(Max)
  // Progress tracking fields for real-time dashboard
  CurrentStep       String?   @db.NVarChar(50)   // e.g., "Step 2/5"
  CurrentStepDetail String?   @db.NVarChar(500)  // e.g., "Polling: RUNNING, 12,450 objects"
  ProgressPercent   Int?                          // 0-100
  RecordsProcessed  Int?                          // Current count processed
  TotalRecords      Int?                          // Expected total (from bulk op)

  @@index([Status, StartedAt], map: "IX_ShopifySyncRun_Status_StartedAt")
}

model Sku {
  ID                      BigInt         @id(map: "PK_Sku") @default(autoincrement())
  SkuID                   String         @db.VarChar(50)
  Description             String?        @db.NVarChar(Max)
  Quantity                Int?
  Price                   String?        @db.NVarChar(100)
  Size                    String?        @db.NVarChar(50)
  FabricContent           String?        @db.NVarChar(Max)
  SkuColor                String?        @db.NVarChar(400)
  ProductType             String?        @db.NVarChar(200)
  DateAdded               DateTime?      @default(now(), map: "DF_Sku_DateAdded") @db.DateTime
  DateModified            DateTime?      @default(now(), map: "DF_Sku_DateModified") @db.DateTime
  CategoryID              Int?
  OnRoute                 Int?
  PriceCAD                String?        @db.NVarChar(100)
  PriceUSD                String?        @db.NVarChar(100)
  ShowInPreOrder          Boolean?
  OrderEntryDescription   String?        @db.NVarChar(Max)
  MSRPCAD                 String?        @db.NVarChar(100)
  MSRPUSD                 String?        @db.NVarChar(100)
  UnitsPerSku             Int?           @default(1)
  UnitPriceCAD            Decimal?       @db.Decimal(10, 2)
  UnitPriceUSD            Decimal?       @db.Decimal(10, 2)
  OnRouteAvailableDate    DateTime?      @db.DateTime
  Season                  String?        @db.NVarChar(500)
  DisplayPriority         Int?
  ShopifyProductVariantId BigInt?
  SyncOrderTemp           Int?
  ShopifyImageURL         String?        @db.NVarChar(500)
  ThumbnailPath           String?        @db.NVarChar(500)
  CollectionID            Int?
  SkuCategories           SkuCategories? @relation(fields: [CategoryID], references: [ID], onDelete: NoAction, onUpdate: NoAction, map: "FK_Sku_SkuCategories")
  Collection              Collection?    @relation(fields: [CollectionID], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_Sku_Collection")
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model Sku_ForTransformationOnly {
  ID                      BigInt    @default(autoincrement())
  SkuID                   String    @db.VarChar(50)
  Description             String?   @db.NVarChar(Max)
  Quantity                Int?
  Price                   String?   @db.NVarChar(100)
  Size                    String?   @db.NVarChar(50)
  FabricContent           String?   @db.NVarChar(Max)
  SkuColor                String?   @db.NVarChar(400)
  DateAdded               DateTime? @db.DateTime
  DateModified            DateTime? @db.DateTime
  CategoryID              Int?
  OnRoute                 Int?
  PriceCAD                String?   @db.NVarChar(100)
  PriceUSD                String?   @db.NVarChar(100)
  ShowInPreOrder          Boolean?
  OrderEntryDescription   String?   @db.NVarChar(Max)
  MSRPCAD                 String?   @db.NVarChar(100)
  MSRPUSD                 String?   @db.NVarChar(100)
  OnRouteAvailableDate    DateTime? @db.DateTime
  Season                  String?   @db.NVarChar(500)
  DisplayPriority         Int?
  ShopifyProductVariantId BigInt?
  SyncOrderTemp           Int?
  ShopifyImageURL         String?   @db.NVarChar(500)

  @@ignore
}

model SkuCategories {
  ID                      Int               @id(map: "PK_SkuCategory") @default(autoincrement())
  Name                    String            @db.NVarChar(500)
  IsPreOrder              Boolean?
  OnRouteAvailableDate    DateTime?         @db.DateTime
  OnRouteAvailableDateEnd DateTime?         @db.DateTime
  ShopifyOrderTags        String?           @db.NVarChar(Max)
  SortOrder               Int?
  ShopifyImages           Boolean?
  Sku                     Sku[]
  SkuMainSubRship         SkuMainSubRship[]
}

model SkuCategoriesShopify {
  ID                      Int          @id(map: "PK_SkuCategoriesShopify") @default(autoincrement())
  Name                    String       @db.NVarChar(500)
  IsPreOrder              Boolean?
  OnRouteAvailableDate    DateTime?    @db.DateTime
  OnRouteAvailableDateEnd DateTime?    @db.DateTime
  SkuShopify              SkuShopify[]
}

model SkuMainCategory {
  ID              Int               @id(map: "PK_SkuMainCategory") @default(autoincrement())
  Name            String            @db.NVarChar(250)
  DisplayOrder    Int?
  SkuMainSubRship SkuMainSubRship[]
}

model SkuMainSubRship {
  ID              Int             @id(map: "PK_SkuMainSubRship_1") @default(autoincrement())
  SkuMainCatID    Int
  SkuSubCatID     Int
  SkuCategories   SkuCategories   @relation(fields: [SkuSubCatID], references: [ID], onUpdate: NoAction, map: "FK_SkuMainSubRship_SkuCategories")
  SkuMainCategory SkuMainCategory @relation(fields: [SkuMainCatID], references: [ID], onUpdate: NoAction, map: "FK_SkuMainSubRship_SkuMainCategory")
}

model SkuQuantity {
  ID              Int        @id(map: "PK_SkuQuantity") @default(autoincrement())
  SkuID           String     @db.VarChar(50)
  WareHouseID     Int
  ReceiptQuantity Int
  SaleQuantity    Int
  InvoiceQuantity Int
  QuantityLeft    Int
  Warehouses      Warehouses @relation(fields: [WareHouseID], references: [ID], onUpdate: NoAction, map: "FK_SkuQuantity_Warehouses")
}

model SkusFetchedFromQuickbooks {
  ID          Int    @id(map: "PK_SkusFetchedFromQuickbooks") @default(autoincrement())
  Sku         String @db.NVarChar(50)
  Quantity    String @db.NVarChar(50)
  Price       String @db.NVarChar(50)
  Description String @db.NVarChar(500)
  Country     String @db.NVarChar(500)
}

model SkusForQBTest {
  ID           Int       @default(autoincrement())
  SkuID        String    @id(map: "PK_Sku_ID_ForQBTest") @db.VarChar(50)
  Description  String?   @db.NVarChar(Max)
  Quantity     Int?
  Price        String?   @db.NVarChar(100)
  Size         String?   @db.NVarChar(50)
  DateAdded    DateTime? @db.DateTime
  DateModified DateTime? @db.DateTime
  CategoryID   Int?
}

model SkuShopify {
  ID                      BigInt                @id(map: "PK_SkuShopify") @default(autoincrement())
  SkuID                   String                @db.VarChar(50)
  Description             String?               @db.NVarChar(Max)
  Quantity                Int?
  Price                   String?               @db.NVarChar(100)
  Size                    String?               @db.NVarChar(50)
  FabricContent           String?               @db.NVarChar(Max)
  SkuColor                String?               @db.NVarChar(200)
  DateAdded               DateTime?             @default(now(), map: "DF_SkuShopify_DateAdded") @db.DateTime
  DateModified            DateTime?             @default(now(), map: "DF_SkuShopify_DateModified") @db.DateTime
  CategoryID              Int?
  OnRoute                 Int?
  PriceCAD                String?               @db.NVarChar(100)
  PriceUSD                String?               @db.NVarChar(100)
  ShowInPreOrder          Boolean?
  OrderEntryDescription   String?               @db.NVarChar(Max)
  MSRPCAD                 String?               @db.NVarChar(100)
  MSRPUSD                 String?               @db.NVarChar(100)
  OnRouteAvailableDate    DateTime?             @db.DateTime
  Season                  String?               @db.NVarChar(500)
  DisplayPriority         Int?
  ShopifyProductVariantId BigInt?
  SkuCategoriesShopify    SkuCategoriesShopify? @relation(fields: [CategoryID], references: [ID], onDelete: NoAction, onUpdate: NoAction, map: "FK_SkuShopify_SkuCategoriesShopify")
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model tmpJSONOrders {
  vJSON String? @db.NVarChar(Max)
  Id    Int?

  @@ignore
}

model Users {
  ID                Int          @id(map: "PK_Users") @default(autoincrement())
  LoginID           String       @db.NVarChar(50)
  Password          String?      @db.NVarChar(50) // Legacy plaintext - deprecated
  PasswordHash      String?      @db.NVarChar(255) // bcrypt hash
  UserType          String       @db.NVarChar(50)
  RepId             Int?
  Status            String       @default("legacy") @db.NVarChar(20) // invited, active, legacy, disabled
  MustResetPassword Boolean?     @default(true)
  Email             String?      @db.NVarChar(255)
  Preferences       String?      @db.NVarChar(Max) // JSON object for user preferences
  Reps              Reps?        @relation(fields: [RepId], references: [ID], onDelete: NoAction, onUpdate: NoAction, map: "FK_Users_Reps")
  AuthTokens        AuthTokens[]
}

model AuthTokens {
  ID        Int       @id(map: "PK_AuthTokens") @default(autoincrement())
  UserID    Int
  TokenHash String    @db.NVarChar(255)
  TokenType String    @db.NVarChar(20) // 'invite' or 'password_reset'
  ExpiresAt DateTime  @db.DateTime
  UsedAt    DateTime? @db.DateTime
  CreatedAt DateTime  @default(now()) @db.DateTime
  User      Users     @relation(fields: [UserID], references: [ID], onDelete: Cascade, map: "FK_AuthTokens_Users")

  @@index([TokenHash], map: "IX_AuthTokens_TokenHash")
  @@index([UserID, TokenType], map: "IX_AuthTokens_UserID_Type")
}

model Warehouses {
  ID          Int           @id(map: "PK_Warehouses") @default(autoincrement())
  Name        String        @db.NVarChar(Max)
  SkuQuantity SkuQuantity[]
}

model OrderNumberSequence {
  Prefix     String   @id @db.Char(1) // 'A' or 'P'
  LastNumber Int      @default(10000)
  UpdatedAt  DateTime @default(now(), map: "DF__OrderNumb__Updat__631A7FBD") @db.DateTime
}

model Collection {
  id              Int                   @id @default(autoincrement()) @map("ID")
  name            String                @map("Name") @db.NVarChar(500)
  type            String                @map("Type") @db.NVarChar(20) // 'ATS' or 'PreOrder'
  sortOrder       Int                   @default(0) @map("SortOrder")
  imageUrl        String?               @map("ImageUrl") @db.NVarChar(500)
  shipWindowStart DateTime?             @map("ShipWindowStart") @db.DateTime
  shipWindowEnd   DateTime?             @map("ShipWindowEnd") @db.DateTime
  isActive        Boolean               @default(true) @map("IsActive")
  createdAt       DateTime              @default(now()) @map("CreatedAt") @db.DateTime
  updatedAt       DateTime              @default(now()) @map("UpdatedAt") @db.DateTime
  skus            Sku[]
  mappings        ShopifyValueMapping[]

  @@map("Collection")
}

model ShopifyValueMapping {
  id           Int         @id @default(autoincrement()) @map("ID")
  rawValue     String      @unique @map("RawValue") @db.NVarChar(1000)
  collectionId Int?        @map("CollectionID")
  status       String      @default("unmapped") @map("Status") @db.NVarChar(20) // 'mapped', 'unmapped', 'deferred'
  note         String?     @map("Note") @db.NVarChar(500)
  skuCount     Int         @default(0) @map("SkuCount")
  firstSeenAt  DateTime    @default(now()) @map("FirstSeenAt") @db.DateTime
  lastSeenAt   DateTime    @default(now()) @map("LastSeenAt") @db.DateTime
  collection   Collection? @relation(fields: [collectionId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_ShopifyValueMapping_Collection")

  @@map("ShopifyValueMapping")
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model PG_Desc_OED {
  ID                    String? @db.NVarChar(255)
  SkuID                 String? @db.NVarChar(255)
  Description           String? @db.NVarChar(255)
  Quantity              Float?
  Pack_Size             String? @map("Pack Size") @db.NVarChar(255)
  Price                 String? @db.NVarChar(255)
  Fabric_Content        String? @map("Fabric Content") @db.NVarChar(255)
  SkuColor              String? @db.NVarChar(255)
  DateAdded             String? @db.NVarChar(255)
  DateModified          String? @db.NVarChar(255)
  CategoryID            Float?
  PriceCAD              Float?
  PriceUSD              Float?
  Price_Pack_CAD        Float?  @map("Price Pack CAD")
  Price_Pack_USD        Float?  @map("Price Pack USD")
  OrderEntryDescription String? @db.NVarChar(255)
  MSRPCAD               Float?
  MSRPUSD               Float?
  Season                String? @db.NVarChar(255)
  IsReviewed            String? @db.NVarChar(255)

  @@ignore
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model PGSkus20240204 {
  ID                    String? @db.NVarChar(255)
  SkuID                 String? @db.NVarChar(255)
  Description           String? @db.NVarChar(255)
  Quantity              Float?
  Fabric_Content        String? @map("Fabric Content") @db.NVarChar(255)
  SkuColor              String? @db.NVarChar(255)
  DateAdded             String? @db.NVarChar(255)
  DateModified          String? @db.NVarChar(255)
  CategoryID            Float?
  PriceCAD              Float?
  PriceUSD              Float?
  OrderEntryDescription String? @db.NVarChar(255)
  MSRPCAD               Float?
  MSRPUSD               Float?
  Season                String? @db.NVarChar(255)
  IsReviewed            String? @db.NVarChar(255)

  @@ignore
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model PPGPrices {
  SkuID        String? @db.NVarChar(255)
  CategoryID   Float?
  PriceCAD     Float?
  PriceUSD     Float?
  PricePackCAD Float?
  PricePackUSD Float?
  MSRPCAD      Float?
  MSRPUSD      Float?

  @@ignore
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model PPGPricesN {
  SkuID        String? @db.NVarChar(255)
  CategoryID   Float?
  PriceCAD     Float?
  PriceUSD     Float?
  PricePackCAD Float?
  PricePackUSD Float?
  MSRPCAD      Float?
  MSRPUSD      Float?

  @@ignore
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model PPGPricesN_20240110 {
  SkuID        String? @db.NVarChar(255)
  CategoryID   Float?
  PriceCAD     Float?
  PriceUSD     Float?
  PricePackCAD Float?
  PricePackUSD Float?
  MSRPCAD      Float?
  MSRPUSD      Float?

  @@ignore
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model PPGPricesN_Modified {
  SkuID        String? @db.NVarChar(255)
  CategoryID   Float?
  PriceCAD     Float?
  PriceUSD     Float?
  PricePackCAD Float?
  PricePackUSD Float?
  MSRPCAD      Float?
  MSRPUSD      Float?

  @@ignore
}

model RepTargets {
  ID           Int       @id(map: "PK__RepTarge__3214EC27E6929715") @default(autoincrement())
  RepID        Int
  PeriodType   String    @db.NVarChar(20)
  PeriodStart  DateTime  @db.DateTime
  TargetAmount Decimal   @db.Decimal(18, 2)
  CreatedAt    DateTime  @default(now(), map: "DF__RepTarget__Creat__208CD6FA") @db.DateTime
  UpdatedAt    DateTime? @db.DateTime
  Reps         Reps      @relation(fields: [RepID], references: [ID], onUpdate: NoAction, map: "FK_RepTargets_Reps")

  @@index([PeriodType, PeriodStart], map: "IX_RepTargets_Period")
  @@index([RepID], map: "IX_RepTargets_RepID")
}

model AliasSignals {
  ID             Int       @id(map: "PK__AliasSig__3214EC27A01A4005") @default(autoincrement())
  EntityType     String    @db.NVarChar(50)
  SelectedValues String    @db.NVarChar(Max)
  ReportType     String    @db.NVarChar(50)
  CreatedBy      Int?
  CreatedAt      DateTime? @default(now(), map: "DF__AliasSign__Creat__245D67DE")
  SessionID      String?   @db.NVarChar(100)

  @@index([CreatedAt], map: "IX_AliasSignals_CreatedAt")
  @@index([EntityType], map: "IX_AliasSignals_EntityType")
  @@index([ReportType], map: "IX_AliasSignals_ReportType")
}

/// Shipment records for orders - tracks what was actually shipped vs ordered
model Shipments {
  ID               BigInt             @id(map: "PK_Shipments") @default(autoincrement())
  CustomerOrderID  BigInt
  ShippedSubtotal  Float              @default(0)
  ShippingCost     Float              @default(0)
  ShippedTotal     Float              @default(0)
  ShipDate         DateTime?          @db.DateTime
  InternalNotes    String?            @db.NVarChar(Max)
  CreatedBy        String             @db.NVarChar(255)
  CreatedAt        DateTime           @default(now()) @db.DateTime
  UpdatedAt        DateTime?          @db.DateTime
  ShopifyFulfillmentID String?        @db.NVarChar(50)
  // Void fields - allows marking shipments as voided without deletion
  VoidedAt         DateTime?          @db.DateTime
  VoidedBy         String?            @db.NVarChar(255)
  VoidReason       String?            @db.NVarChar(100)
  VoidNotes        String?            @db.NVarChar(Max)
  CustomerOrders   CustomerOrders     @relation(fields: [CustomerOrderID], references: [ID], onUpdate: NoAction, map: "FK_Shipments_CustomerOrders")
  ShipmentItems    ShipmentItems[]
  ShipmentTracking ShipmentTracking[]
  ShipmentDocuments ShipmentDocuments[]

  @@index([CustomerOrderID], map: "IX_Shipments_CustomerOrderID")
  @@index([VoidedAt], map: "IX_Shipments_VoidedAt")
}

/// Line items included in a shipment - links to order items with quantity shipped
model ShipmentItems {
  ID              BigInt              @id(map: "PK_ShipmentItems") @default(autoincrement())
  ShipmentID      BigInt
  OrderItemID     BigInt
  QuantityShipped Int
  PriceOverride   Float?
  Shipment        Shipments           @relation(fields: [ShipmentID], references: [ID], onUpdate: NoAction, map: "FK_ShipmentItems_Shipments")
  OrderItem       CustomerOrdersItems @relation(fields: [OrderItemID], references: [ID], onUpdate: NoAction, map: "FK_ShipmentItems_CustomerOrdersItems")

  @@index([ShipmentID], map: "IX_ShipmentItems_ShipmentID")
  @@index([OrderItemID], map: "IX_ShipmentItems_OrderItemID")
}

/// Tracking numbers for shipments - supports multiple tracking numbers per shipment
model ShipmentTracking {
  ID             BigInt    @id(map: "PK_ShipmentTracking") @default(autoincrement())
  ShipmentID     BigInt
  Carrier        String    @db.NVarChar(50)
  TrackingNumber String    @db.NVarChar(100)
  AddedAt        DateTime  @default(now()) @db.DateTime
  Shipment       Shipments @relation(fields: [ShipmentID], references: [ID], onUpdate: NoAction, map: "FK_ShipmentTracking_Shipments")

  @@index([ShipmentID], map: "IX_ShipmentTracking_ShipmentID")
}

/// Tracks which SQL migrations have been applied to the database
model SchemaMigrations {
  ID        Int      @id(map: "PK_SchemaMigrations") @default(autoincrement())
  Name      String   @unique(map: "UQ_SchemaMigrations_Name") @db.NVarChar(255)
  AppliedAt DateTime @default(now()) @db.DateTime

  @@map("SchemaMigrations")
}

/// Feature interest tracking - captures user expectations for upcoming features
model FeatureInterest {
  ID              BigInt   @id(map: "PK_FeatureInterest") @default(autoincrement())
  Feature         String   @db.NVarChar(100)
  SelectedOptions String?  @db.NVarChar(Max)
  FreeText        String?  @db.NVarChar(Max)
  OrderId         BigInt?
  OrderNumber     String?  @db.NVarChar(50)
  UserId          String?  @db.NVarChar(255)
  CreatedAt       DateTime @default(now()) @db.DateTime

  @@index([Feature], map: "IX_FeatureInterest_Feature")
  @@index([CreatedAt], map: "IX_FeatureInterest_CreatedAt")
}

/// Shipment documents - stores generated PDFs (packing slips, invoices)
model ShipmentDocuments {
  ID             BigInt    @id(map: "PK_ShipmentDocuments") @default(autoincrement())
  ShipmentID     BigInt
  OrderID        BigInt
  DocumentType   String    @db.NVarChar(50)  // 'packing_slip', 'shipping_invoice'
  DocumentNumber String    @db.NVarChar(100) // 'PS-A10001-1', 'INV-A10001-1'
  FileName       String    @db.NVarChar(255)
  FilePath       String    @db.NVarChar(500) // S3 key or local path
  FileSize       Int?
  MimeType       String    @default("application/pdf") @db.NVarChar(100)
  GeneratedAt    DateTime  @default(now()) @db.DateTime
  GeneratedBy    String?   @db.NVarChar(255)
  SentToCustomer Boolean   @default(false)
  SentAt         DateTime? @db.DateTime
  Shipment       Shipments @relation(fields: [ShipmentID], references: [ID], onDelete: Cascade, map: "FK_ShipmentDocuments_Shipment")

  @@index([ShipmentID], map: "IX_ShipmentDocuments_ShipmentID")
  @@index([OrderID], map: "IX_ShipmentDocuments_OrderID")
  @@index([DocumentNumber], map: "IX_ShipmentDocuments_DocumentNumber")
  @@index([DocumentType], map: "IX_ShipmentDocuments_DocumentType")
}

/// Backup table for orphaned CustomerOrdersItems (audit/archive purposes)
/// Created during migration to clean up data integrity issues
model CustomerOrdersItems_Orphaned_Backup {
  ID              BigInt  @id(map: "PK_CustomerOrdersItems_Orphaned_Backup")
  CustomerOrderID BigInt
  OrderNumber     String  @db.NVarChar(50)
  SKU             String  @db.NVarChar(50)
  SKUVariantID    BigInt
  Quantity        Int
  Price           Float
  PriceCurrency   String  @db.NVarChar(50)
  Notes           String  @db.NVarChar(Max)
  LineDiscount    Float?
  Status          String? @db.NVarChar(20)
  CancelledQty    Int?
  CancelledAt     DateTime? @db.DateTime
  CancelledBy     String?   @db.NVarChar(255)
  CancelledReason String?   @db.NVarChar(100)
}

/// Backup table for orphaned AuthTokens (audit/archive purposes)
/// Created during migration to clean up data integrity issues
model AuthTokens_Orphaned_Backup {
  ID        BigInt   @id(map: "PK_AuthTokens_Orphaned_Backup")
  UserID    BigInt
  Token     String   @db.NVarChar(500)
  ExpiresAt DateTime @db.DateTime
  CreatedAt DateTime @db.DateTime
}

// ============================================================================
// Backup System (Normalized Data Model)
// ============================================================================
// Backups are stored as proper data, not dynamic tables. This allows:
// - Full Prisma management (no schema conflicts)
// - Admin UI visibility and controls
// - Configurable retention policies
// - Easy querying and restoration
//
// Created by: backupSkuTable() in sync.ts
// Cleaned up by: cleanupOldBackups() based on retention settings
// ============================================================================

/// A set of backup rows created at a specific point in time
model BackupSet {
  id            Int       @id @default(autoincrement())
  backupType    String    @db.NVarChar(50)   // 'Sku', 'Order', 'Customer', etc.
  description   String?   @db.NVarChar(255)  // 'Pre-sync backup', 'Manual backup', etc.
  rowCount      Int                          // Number of rows in this backup
  sizeBytes     Int?                         // Approximate size for UI display
  createdAt     DateTime  @default(now())
  createdBy     String?   @db.NVarChar(100)  // 'system' or user email
  status        String    @default("active") @db.NVarChar(20) // active, restored, deleted

  rows          BackupRow[]

  @@index([backupType, createdAt])
  @@index([status])
}

/// Individual rows within a backup set, stored as JSON
model BackupRow {
  id          BigInt    @id @default(autoincrement())
  backupSetId Int
  rowData     String    @db.NVarChar(Max)   // JSON serialization of the original row

  backupSet   BackupSet @relation(fields: [backupSetId], references: [id], onDelete: Cascade)

  @@index([backupSetId])
}

// ============================================================================
// Shopify Sync Configuration (Developer Tools)
// ============================================================================
// These tables power the Developer Tools UI for configuring Shopify sync:
// - Which fields to sync from each entity type
// - Filters to apply (e.g., only ACTIVE products)
// - Cached schema introspection results
// - Audit trail of all configuration changes
// ============================================================================

/// Configuration for which Shopify fields to sync per entity type
model SyncFieldConfig {
  id           Int       @id @default(autoincrement())
  entityType   String    @db.NVarChar(50)   // Product, ProductVariant, Collection
  fieldPath    String    @db.NVarChar(200)  // status, metafield_custom_season
  fieldType    String    @db.NVarChar(50)   // SCALAR, OBJECT, CONNECTION, ENUM
  category     String?   @db.NVarChar(50)   // system, scalar, enum, connection, metafield
  description  String?   @db.NVarChar(500)  // From schema introspection
  displayOrder Int       @default(0)        // For UI sorting
  enabled      Boolean   @default(false)
  isProtected  Boolean   @default(false)    // Cannot be disabled (id, sku, price, etc.)
  isMetafield  Boolean   @default(false)
  accessStatus String?   @db.NVarChar(20)   // accessible, restricted, untested
  lastProbedAt DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([entityType, fieldPath])
  @@index([entityType])
  @@index([isProtected])
}

/// Filter rules for sync (e.g., only sync ACTIVE products)
/// Multiple filters on same entity are AND'd together
model SyncFilterConfig {
  id          Int      @id @default(autoincrement())
  entityType  String   @db.NVarChar(50)   // Product
  fieldPath   String   @db.NVarChar(200)  // status
  operator    String   @db.NVarChar(20)   // equals, in, not_in
  value       String   @db.NVarChar(500)  // ACTIVE or ["ACTIVE","DRAFT"] (JSON)
  enabled     Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([entityType, fieldPath])
  @@index([entityType, enabled])
}

/// Runtime config for sync behavior (status cascade arrays, flags)
model SyncRuntimeConfig {
  id          Int      @id @default(autoincrement())
  entityType  String   @db.NVarChar(50)   // Product
  configKey   String   @db.NVarChar(100)  // ingestionAllowed, skuAllowed, transferAllowed
  configValue String?  @db.NVarChar(Max)  // JSON value (e.g., '["ACTIVE","DRAFT"]')
  enabled     Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([entityType, configKey])
  @@index([entityType, enabled])
}

/// Cached Shopify GraphQL schema introspection results
model ShopifySchemaCache {
  id          Int       @id @default(autoincrement())
  entityType  String    @unique @db.NVarChar(50)  // Product, ProductVariant, etc.
  apiVersion  String    @db.NVarChar(20)          // e.g., "2024-01"
  schemaJson  String    @db.NVarChar(Max)         // Full introspection result
  fetchedAt   DateTime  @default(now())
  expiresAt   DateTime?                           // Optional TTL
}

/// Audit trail for all sync configuration changes
model SyncConfigAudit {
  id            Int      @id @default(autoincrement())
  configType    String   @db.NVarChar(50)   // 'field' or 'filter'
  entityType    String   @db.NVarChar(50)
  fieldPath     String   @db.NVarChar(200)
  action        String   @db.NVarChar(20)   // 'enabled', 'disabled', 'created', 'updated', 'deleted'
  previousValue String?  @db.NVarChar(500)
  newValue      String?  @db.NVarChar(500)
  changedBy     String   @db.NVarChar(255)
  changedAt     DateTime @default(now())

  @@index([entityType, changedAt])
  @@index([changedBy])
}

// ============================================================================
// Sync Service: ETL Pipeline (Mapping & Scheduling)
// ============================================================================
// These tables power the sync service's ETL pipeline:
// - SyncMapping: HOW to transform Shopify data and WHERE to write it
// - SyncSchedule: WHEN to run syncs (cron-based scheduling)
// - SyncRun: History of sync execution runs
// - WebhookHistory: Incoming webhook tracking
//
// Relationship to SyncFieldConfig:
// - SyncFieldConfig = WHAT fields to fetch from Shopify (field selection)
// - SyncMapping = HOW to transform + WHERE to write (ETL mapping)
// They are complementary, not duplicates.
// ============================================================================

/// Mapping configuration: source resource -> target table with field transformations
model SyncMapping {
  id             String         @id @default(uuid())
  name           String         @db.NVarChar(200)
  description    String?        @db.NVarChar(500)
  sourceResource String         @db.NVarChar(100)  // products, collections, orders, etc.
  targetTable    String         @db.NVarChar(200)  // dbo.Sku, dbo.RawSkusFromShopify, etc.
  keyMapping     String?        @db.NVarChar(Max)  // JSON: source key -> target key mapping
  mappingsJson   String         @db.NVarChar(Max)  // JSON: array of field mappings with transforms
  webhookTopics  String?        @db.NVarChar(500)  // Comma-separated: products/update, products/create
  enabled        Boolean        @default(true)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  schedules      SyncSchedule[]
  runs           SyncRun[]

  @@index([enabled])
  @@index([sourceResource])
}

/// Schedule configuration for automated syncs
model SyncSchedule {
  id               String       @id @default(uuid())
  mappingId        String
  type             String       @db.NVarChar(20)   // full, incremental
  cronPattern      String       @db.NVarChar(100)  // e.g., "0 */15 * * *" (every 15 min)
  timezone         String       @default("UTC") @db.NVarChar(50)
  enabled          Boolean      @default(true)
  options          String?      @db.NVarChar(Max)  // JSON: { lookbackMinutes, deleteStale, etc. }
  nextRun          DateTime?
  lastRun          DateTime?
  lastStatus       String?      @db.NVarChar(20)   // success, failed, skipped
  consecutiveFails Int          @default(0)
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  mapping          SyncMapping  @relation(fields: [mappingId], references: [id], onDelete: Cascade)

  @@index([enabled, nextRun])
  @@index([mappingId])
}

/// History of sync run executions
model SyncRun {
  id             String       @id @default(uuid())
  mappingId      String?
  syncType       String       @db.NVarChar(20)   // full, incremental, webhook
  status         String       @db.NVarChar(20)   // running, completed, failed, cancelled
  triggeredBy    String?      @db.NVarChar(100)  // manual, schedule, webhook, api
  startedAt      DateTime     @default(now())
  completedAt    DateTime?
  recordsFetched Int?
  recordsWritten Int?
  recordsSkipped Int?
  recordsFailed  Int?
  durationMs     Int?
  errorMessage   String?      @db.NVarChar(Max)
  metadata       String?      @db.NVarChar(Max)  // JSON: additional run details
  mapping        SyncMapping? @relation(fields: [mappingId], references: [id], onDelete: SetNull)

  @@index([status, startedAt])
  @@index([mappingId])
  @@index([syncType])
}

/// History of received Shopify webhooks
model WebhookHistory {
  id                String    @id @default(uuid())
  shopifyWebhookId  String    @unique @db.NVarChar(100)
  topic             String    @db.NVarChar(100)  // products/update, orders/create, etc.
  shopDomain        String    @db.NVarChar(200)
  receivedAt        DateTime  @default(now())
  processedAt       DateTime?
  status            String    @db.NVarChar(20)   // pending, processing, completed, failed, skipped
  mappingsProcessed Int?
  recordsWritten    Int?
  processingMs      Int?
  errorMessage      String?   @db.NVarChar(Max)

  @@index([status, receivedAt])
  @@index([topic])
  @@index([shopifyWebhookId])
}

// ============================================================================
// Sync Settings (Configurable via UI)
// ============================================================================
// Centralized settings for sync behavior, thumbnails, backups.
// Versioned for audit trail - see what changed if sync behavior differs.
//
// Related: SyncSettingsHistory stores snapshots of previous versions.
// ============================================================================

/// Global sync settings - configurable via admin UI at /admin/shopify/settings
model SyncSettings {
  id                        Int      @id @default(autoincrement()) @map("ID")
  version                   Int      @default(1) @map("Version")

  // Thumbnail Configuration
  thumbnailSettingsVersion  Int      @default(3) @map("ThumbnailSettingsVersion")
  thumbnailSizeSm           Int      @default(120) @map("ThumbnailSizeSm")
  thumbnailSizeMd           Int      @default(240) @map("ThumbnailSizeMd")
  thumbnailSizeLg           Int      @default(480) @map("ThumbnailSizeLg")
  thumbnailQuality          Int      @default(80) @map("ThumbnailQuality")
  thumbnailFit              String   @default("contain") @map("ThumbnailFit") @db.NVarChar(20)
  thumbnailBackground       String   @default("#FFFFFF") @map("ThumbnailBackground") @db.NVarChar(10)

  // Thumbnail Processing
  thumbnailFetchTimeoutMs   Int      @default(15000) @map("ThumbnailFetchTimeoutMs")
  thumbnailBatchConcurrency Int      @default(10) @map("ThumbnailBatchConcurrency")
  thumbnailEnabled          Boolean  @default(true) @map("ThumbnailEnabled")

  // Backup Settings
  backupEnabled             Boolean  @default(true) @map("BackupEnabled")
  backupRetentionDays       Int      @default(7) @map("BackupRetentionDays")
  cleanupStaleBackups       Boolean  @default(true) @map("CleanupStaleBackups")

  // Sync Settings
  syncMaxWaitMs             Int      @default(600000) @map("SyncMaxWaitMs")
  syncPollIntervalMs        Int      @default(3000) @map("SyncPollIntervalMs")

  updatedAt                 DateTime @default(now()) @updatedAt @map("UpdatedAt")

  // Relation to history
  history                   SyncSettingsHistory[]

  @@map("SyncSettings")
}

/// History of sync settings changes for audit trail
model SyncSettingsHistory {
  id          Int          @id @default(autoincrement()) @map("ID")
  settingsId  Int          @map("SettingsID")
  version     Int          @map("Version")
  snapshot    String       @map("Snapshot") @db.NVarChar(Max)  // JSON of settings at that version
  changedBy   String?      @map("ChangedBy") @db.NVarChar(100)
  changedAt   DateTime     @default(now()) @map("ChangedAt")
  changeNote  String?      @map("ChangeNote") @db.NVarChar(500)

  settings    SyncSettings @relation(fields: [settingsId], references: [id], onDelete: Cascade)

  @@index([settingsId])
  @@map("SyncSettingsHistory")
}

// ============================================================================
// Size Order Configuration
// ============================================================================
// Configurable size ordering for product displays and reports.
// Replaces hardcoded SIZE_ORDER array in size-sort.ts.
// Single-row table pattern (like InventorySettings, CompanySettings).
// ============================================================================

/// Size ordering configuration - defines how sizes sort across the system
model SizeOrderConfig {
  ID        Int      @id(map: "PK_SizeOrderConfig") @default(autoincrement())
  Sizes     String   @db.NVarChar(Max)  // JSON array of size strings
  UpdatedAt DateTime @default(now()) @updatedAt
  UpdatedBy String?  @db.NVarChar(255)
}
